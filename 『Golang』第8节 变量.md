## 什么是变量?

我们应该怎么去理解变量? 在这里我要举一个例子: 

大家应该都知道王者荣耀这个游戏. 当我们在玩王者荣耀的时候, 我们操控的英雄的**血量**是不断变化的, 这个**血量**是存在内存中的. 那么这个**血量**就是一个**变量**. 

**在程序运行的过程中, 其值可以改变的量, 我们就称为变量.**

通过上面例子可以发现:

- 变量是存储在内存中的
- 变量的值是可以改变的

我们说变量是存储在内存中, 那么内存又是什么呢?

内存是一个连续的数据集合, 每一个内存存储区域都有一个唯一的地址标识, 称为内存地址. 就好比我们的身份证一样, 每个人都有一个唯一的身份证.

我们知道了变量是什么, 那么在 Go 语言中, 变量应该如何定义呢?

## 变量的定义

我们现在理解了变量可以用来存储数据，但是我们要存储的数据类型是各种各样的。例如：整数、小数、文本等等。

所以我们必须在定义变量时就要告诉计算机我们要定义的变量存储的是什么类型的数据。那么在内存中就可以根据不同的类型来开辟不同的存储空间。

Go 最基本的变量定义方式是使用 `var` 关键字, 其基本格式为:

```go
var 变量名 数据类型
```

**变量的声明以关键字 `var` 开头, 行尾不需要分号**

比如说, 我们定义一个名称为 `hp` , 类型为 `int` 的变量（若不引用则报错）:

```go
var hp int  // int表示为整型
```

我们来声明一个变量并打印一下看看:

```go
package main

import "fmt"

func main() {
	// 使用 var 定义一个变量, 注意: 变量类型要放在变量名后面
	var hp int
	fmt.Println(hp)
}

// 结果:
0
```

奇怪? 我都没有给 hp 一个具体的值, 怎么打印出来为 0 呢? 

其实, 这是 Go 的一个特点： **当我们在声明一个变量的时候, 如果没有初始值, Go 会给其一个对应类型的默认值.**

既然这样, 我们就给 `hp` 一个值吧.

```go
package main

import "fmt"

func main() {
	// 使用 var 定义一个变量, 注意: 变量类型要放在变量名后面
	var hp int
	hp = 100  // 赋值操作
	fmt.Println(hp)
}

// 结果:
100
```

当然了, 我们也可以在声明变量的时候直接给 `hp` 一个值:

```go
var hp int = 100  // 定义变量并初始化值
```

**如果我们仅仅定义一个变量而没有去使用它, 那么Go就会报错.**

## 定义多个变量

```go
// 定义两个类型都是 int 的变量
var hp, mp int
```

你也可以这样写：

```go
var (
	hp int
	mp int
)
```

既然可以同时定义多个变量, 那么也能同时初始化多个变量

```go
/*定义两个类型都是"int"的变量, 并且分别初始化为相应的值
hp为100, mp为260
*/
var hp, mp int = 100, 260
```

## 自动推导类型

有没有发现当我们定义变量时有一些繁琐, 需要写 `类型`, Go允许我们不写 `类型` , 它会自动帮我们推导出数据对应的类型:

```go
var hp, mp = 100, 260
```

有人说了, 那个 `var` 能不能也去了, 每次都要写, 好麻烦的. 没问题, Go 也允许你（但是要把 = 换成 :=）:

```go
/*定义两个变量，它们分别初始化为相应的值
hp为100, mp为260
编译器会根据初始化的值自动推导出相应的类型
*/
hp, mp := 100, 260  // 注意这里有个冒号 :
```

现在是不是感觉非常简洁了. `:=` 这个符号直接代替了变量的定义及赋值.

```go
hp := 100
// 等价于下面两行
var hp int
hp = 100
```

所谓自动推导类型，就是不用通过 `var` 声明变量，不用指定类型，直接在变量名后面跟 `:` 号，同时完成赋值。

那么GO会根据所赋的值自动推导出变量的类型。如果给 `hp` 变量赋值为小数，那么该变量的类型为小数类型（浮点）。

通过比较，我们发现这种方式比前面的赋值方式要简单方便。这种方式，也是我们以后开发过程中最常用的方式。

不过它有一个限制, 那就是它**只能用在函数内部**; 在函数外部使用则会无法编译通过, 所以一般用`var`方式来定义全局变量.

## 匿名变量

`_` (下划线)为**匿名变量**, 它会丢弃对应数据不进行处理. 匿名变量配合函数的返回值使用才有价值, 目前大家先知道其语法即可.

在下面的例子中, 我们将值 `2` 赋予 `b` , 丢弃 `3` 

```go
_, b := 3, 2
```

**匿名变量不占用命名空间, 不会分配内存.**

**匿名变量与匿名变量之间也不会因为多次声明而无法使用.**

## 小练习

有两个变量 a 和 b，a 的值为 10，b 的值为 20，如何交换两个变量的值？

**方法一（传统方式）：**

```go
package main

import "fmt"

func main(){
    a, b := 10, 20
    var temp int
    temp = a
    a = b
    b = temp
    fmt.Println("a = ", a, "b = ", b)
}
```

**方法二（多重赋值）：**

```go
package main

import "fmt"

func main(){
    a, b := 10, 20
    a, b = b, a  // 注意，这一行不需要 冒号
    fmt.Println("a = ", a, "b = ", b)
}
```

## 李培冠博客

[lpgit.com](https://lpgit.com)
